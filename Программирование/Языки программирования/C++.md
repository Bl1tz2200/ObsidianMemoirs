#Программирование #ЯзыкиПрограммирования

С++ - компилируемый, статически типизированный язык программирования общего назначения
С++ это язык, который позволяет выполнять команды с невероятной скоростью, однако он имеет более сложный синтаксис. Он является низкоуровневым, но с высокоуровневыми абстракциями (ООП, шаблоны и функции)

Ниже представлена некоторая информация по C++, которую я решил выделить. 
**Если необходимо полностью изучить C++ советую сразу обратиться к источнику.**

# Типы данных
В этом блоке рассмотрены некоторые особенности типов данных в C++
## Сhar
Тип char создан для однобайтового символа

```
char i = 'i'; // единичные кавычки - один символ
```

Также можно задавать сразу массив из однобайтовых символов:

```
char ioi[] = "ioi";
```

или

```
#include <string>
std::string ioi = "ioi"; // двойные кавычки - много символов
```

## Массивы
Массив нужно либо определять изначально, либо указывать количество чисел в массиве (для выделения памяти):

```
int arr[] = {3, 7, 5}; // только int в массиве (определяем изначально)
```

или

```
int arr[3];
arr[0] = 3;
arr[1] = 7;
arr[2] = 5;
```

Для создания многомерных массивов нужно заранее определять размер последующих массивов:

```
int arr[][2] = {{1, 2}, {3, 4}}; // для последующий массивов после 1 нужно писать количество элементов в массиве ВСЕГДА
```

Подробнее про массивы можно посмотреть [здесь](https://metanit.com/cpp/tutorial/2.15.php)(там массивы создают 2 способом - `int numbers[]{11, 12, 13, 14}`)

## Указатели
Существуют указатели, указывающие на ячейку памяти с переменной, например:

```
int number = 10;
int *ptrnumber = &number; // указателям приписывают ptr, * значит значение, без неё будет просто адрес
```

Мы просто указываем на переменную, а не копируем её, ускоряя код, при изменении указателя изменится и число, на которое он ссылался

## Ссылки
Существуют и ссылки, которые выполняют похожую на указатели роль, при изменении ссылки изменится и число, на которое она ссылалась:

```
int number = 10;
int &ref = number;
```

Через указатели мы указываем на адрес в памяти объекта, а через ссылку на сам объект

## Структуры
Структуры не отличаются от классов, но являются конкретно типом данных, а не планом для создания других похожих объектов:

```
struct Date {
    int year;
};

struct Auto {
    int wheels;
    int speed;
    Date sozd; // Структуры в структуре
};

int main () {
    Auto shkoda;
    shkoda.sozd.year = 1998; // Обращаемся к структуре в структуре
    Auto audi = {4, 200, 1992};
    return 0;
}
```

# Очистка памяти
Допустим у нас есть код:
```
int *ptrnumbers = new int (10); // выделяем память под массив из 10 объектов (так же как и int numbers[10])
```

Тогда можно очистить память, выделенную для массива (удаляем по адрессу, который использовался при выделении памяти):
```
delete [] ptrnumbers;
```

То же самое можно делать и с обычными переменными (не только с массивами)

# Реализация switch-case
Пример реализации блока switch-case:

```
 switch(i)
    {
        case 'i':
            std::cout << "I is I";
            break; // не забываем про break, иначе код пойдет по case дальше
        case 'o':
            std::cout << "I is O";
            break;
        default: // выполнится если ничего из вышеперечисленного не подойдет
            std::cout << "ERROR: Invalid i." << std::endl;
            break;
    };
```

# Отлавливание ошибок
Пример отлавливания ошибок:

```
int num1 = 1;
int num2 = 0;

std::cout << num1/num2;

try {
    if (num2 == 0){
        throw 1;};
} catch (int i){ // ловим то, что кинули (throw)
    std::cout << "Error" << i;};
```

# Функция main
Функция main всегда возвращает число:

```
int main ()
    {
	    return 0; // код,  с которым завершается программа
	}
```

# Enum
Функция enum автоматически задает порядковые значения переменным, используется вне main. 

По умолчанию отсчет идет от 0, но можно задавать и вручную начало, дальше все будет увеличиваться на 1:

```
enum floors {f1 = 1, f2, f3};
```

Тогда в классе floors f1 = 1, f2 = 2, f3 = 3

# Перезагрузка функций
Перегрузка функции - использование разных функций с одинаковым названием, но разными действиями и принимаемыми переменными (основа полиморфизма):

```
int summ (int i, int j){ std::cout << i+j;};
int summ (int i, int j, int z){ std::cout << i+j+z;};
```

# Глобальная переменная
Если переменная была задана вне функций (даже main), тогда она будет видна всем функциям. Такую переменную называют глобальной

# Классы
## Распределение доступа
В классах можно задать 3 модификатора доступа (в любом порядке, какой удобнее): private, public и protected. Ниже представлен пример с описанием каждого из модификаторов:

```
class Site{
    private: // используется только внутри класса (все, после двоеточия, будет приватным)
        int secret = 100;
	void password (){
           std::cout << "Password is 123";
        }
    public: // используется всеми (все, после двоеточия, будет публичным)
       int value = 10;
       Site () { // используем конструктор внутри класса (когда мы создаем сайт Site без переменных, срабатывает этот конструктор)
           secret = 200;
       }
       Site (int j) { // перегрузка конструктора (когда мы создаем сайт Site с 1 int переменной, срабатывает этот конструктор)
           secret = j;
       }
       ~Site () { // деструктор, срабатывает при завершении класса (его уничтожении, завершении програмы и тд), прописываем в public
        std::cout << "Thats all";
        };
    protected: // используется только внутри класса и наследниках (все, после двоеточия, будет защищенным)
        int i = 5;
	void message (){
           std::cout << "Hello world!";
    }

};
int main (){
    Site site;
    std::cout << site.value;
    return 0;
}
```

## Дружественная функция
Дружественная функция позволяет передавать в неё приватные значения даже если она не была определена в соответствующем классе:


```
class Site2; // определяем, что у нас будет класс Site2, иначе компилятор не поймет, что за Site2 мы указали, не определив его

class Site1{
    friend int password (Site1, Site2); // задаем дружественную функцию
private: 
       int i = 100;
};
class Site2{
    friend int password (Site1, Site2); // задаем дружественную функцию
private: 
       int i = 10;
};

int password (Site1 s1, Site2 s2){ // описываем дружественную функцию
    std::cout << "Password is " << s1.i + s2.i;
    return s1.i + s2.i;
}

int main (){
    Site1 s1;
    Site2 s2;
    int m = password(s1, s2); // 110
    return 0;
}
```

## Дружественный класс
Существуют и дружественные классы, работают так же: дают доступ к приватным значениям другому классу. Пример:

```
class Site2;
class Site1{
     friend class Site2; // задаем дружественный класс
private: 
       int i = 100;
};
class Site2{
public:
	void dec (Site1 s1){ // Используем дружественный класс (можно так же использовать &s1 для изменения i в определенном классе)
        std::cout << s1.i - i;
}
private: 
       int i = 10;
};

int main (){
    Site1 s1;
    Site2 s2;
    s2.dec(s1);
    return 0;
}
```

## Переменные класса
Существует метод для определения переменных внутри класса через использование `this->`:
```
class Site{
    int a;
    int b;
    int c;
    int summ;
    public:
    void func(int a, int b, int c){
        this->a = a; // приравниваем переменные из класса с теми, которые были переданы в функции
        this->b = b;
        this->c = c;
        summ = this->a + this->b + this->c;
        std::cout << summ;
    };
};
```
## Наследование
Пример наследования:
```
class First{
    protected:
    int value = 0;
};

class Second : protected First{ // protected значит, что все, что мы унаследуем, перейдет в блок protected
    public:
    void val (){
        std::cout << value;
    };
};

int main (){
    Second i;
    i.val();
    return 0;
}
```

# Шаблоны
В шаблона типы и константы могут быть вынесены в параметры

Пример шаблона функции:
```
template <typename T> // определяем шаблон с заменной переменной T
void printArr(const T *arr, int size){
    for(int i = 0; i < size; i++){
        std::cout << arr[i] << std::endl;
    }
};

int main (){
    int arr1[5] = {1, 2, 3, 4, 5};
    char arr2[3] = {'a', 'b', 'c'};
    float arr3[11] = {1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2};
    printArr<int>(arr1, 5); // Заменяем T в <>, таким образом можно использовать одну функцию для множества различных типов массивов
    printArr<char>(arr2, 3);
    printArr<float>(arr3, 11);
    return 0;
}
```

Тоже самое, но с классами:
```
template <typename T, int T2> // определяем шаблон
class Arr{
    private:
        T arr[T2];
    public:
        Arr (T *a){
            for(int i = 0; i < T2; i++){
                arr[i] = a[i];
            }
        };

        T get_element(T i){
            return arr[i];
        }
};

int main (){
    int arr[2] = {1, 2};
    Arr<int, 2> array (arr); // передаем значения в шаблон
    int i;
    std::cin >> i;
    std::cout << array.get_element(i) << std::endl;
    return 0;
}
```

# Работа с файлами
Для работы с файлами используем библиотеку fstream

Пример записи в файл:

```
#include <fstream> 
std::ofstream file; // для записи в файл 
file.open("text.txt");
file << "Hello world!";
file.close();
```

Пример чтения файла:

```
#include <fstream> 
std::ifstream file; // для записи из файла
if (file.is_open()) // проверка открылся ли, если открылся, то код продолжится с открытым файлом
{
file >> i;
file.close();
std::cout << i; // Вывод: Hello world!

}
else { 
std::cout << "ERROR: File not found";}
```

# [Источник](https://www.youtube.com/playlist?list=PL0lO_mIqDDFXNfqIL9PHQM7Wg_kOtDZsW)
Источником является обучающий плейлист на ютубе
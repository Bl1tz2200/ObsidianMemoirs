#Программирование #ЯзыкиПрограммирования 

TypeScript - типизатор для JS. Не смотря на то, что фишкой JavaScript является не привязанность к типам данных (да да, сложение строки, числа и bool значения), в JS явно не хватает строгого типизатора значений. Это позволит сделать код понятнее и ловить ошибки ещё на этапе интерпретации

Благодаря TS можно избежать многих ошибок, связанных с типами данных, а за счёт того, что он не является отдельным языком, он не требует долгого изучения при владении JS

Работает TS следующим образом: после написания кода на TS он конвертирует его в JS код, который потом используется в программе/приложении. В Node.js проекте часто присутствует файл tsconfig.json, в нем задаются параметры для TS транспилятора (да, так называют компилятор TS),в этом же файле задают основные файлы для компиляции и игнорируемые файлы

# Функции с указанием типов
Вот пример функции на TS:

```
function addOne(age: number): number { // После двоеточия указываем тип данных, который должен передаваться в age и будет возвращаться в функции
 return age + 1
}
```

Можно так же указывать возможные значения:

```
declare function processNumber(s: 3 | 4) // Функция примет только цифры 3 или 4
// declare - оператор объявления данных (переменных, функций и тд)
```

# Объявление map и vectors
При объявлении своих карт (map), векторов (vectors) или кортежей тоже нужно объявлять данные:

```
// Создаем ассоциативный тип
type User = { // Не забываем указать все типы данных, которые могут храниться в ключах
 id: number
 username: string
 name: string
}

// Создаем объект `user`, соответствующий ассоциативному типу
const user: User = {
 id: 1,
 username: 'Superman',
 name: 'Clark Kent',
}

// Создаем объект `user2`, соответствующий ассоциативному типу
const user2: User = {
 id: 2,
 username: 'WonderWoman',
 name: 'Diana Prince',
}

// Создаем вектор (типизированный массив (массив элементов одного типа)) пользователей
const userVector: User[] = [user1, user2] // В этом случае тип данных вектора - User

// Создаем кортеж
const userTuple: [User, number] = [user1, 10] // В кортеже будут храниться только 2 элемента с типами данных User и number

// Создаем массив
const userTuple: Array<User | number> = [user1, 10, 20, user2, 30] // В массиве будут храниться любые элементы с типами данных User или number
```

# Типы данных в TS
Есть в TS собственные типы данных:

`enum` - ограниченный набор значений
`any` - любой тип данных
`unknown` - альтернатива any
`void` - ничего (например функция, которая не возвращает результат)
`never` - исключение или отсутствие конца (например функция, которая никогда не остановится или имеет внутри исключение)

# Предохранители данных
В TS есть понятие предохранителя данных, они нужны чтобы обезопасить функции или другие методы от ввода неверного типа
Для этого в TS есть разные функции:

Функция проверки типа данных - `typeof`:

```
if (typeof user === 'string') { // Проверяем: равен ли тип данных пользователя string
   return console.log(user)
 }
```

Помимо такой функции есть ещё `instanceof` (является ли объект указанным классом) и in (есть ли такое значение в данном классе, типе данных, массиве и тд) 
(подробнее см. [документацию](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates))

# Предикаты
`as` и `is` называют предикатами 
## As
Используя слово `as` можно указать, что передаваемый параметр будет принадлежать к `ETypes`, чтобы избежать ошибки типов
`as` редко используют так как может вызвать непонятный код. Пример:

```
enum ETypes {
    Big = "big"
    Small = "small"
}

const fn = (value: ETypes) => {
    // Тут должен быть код
};

const a = "big";

fn(a as ETypes) // Этот вызов не вызовет ошибку так как мы передали a как ETypes, мы можем это сделать так как параметр а соответсвтует одному из параметров ETypes следовательно может ему принадлежать
```
## Is
Используя слово `is` можно указывать результат выполнения функции в виде принадлежности к определенному типу данных. Пример:

```
enum ETypes {
    Big = "big"
    Small = "small"
}

const isValueEType = (value: any): value is ETypes => Object.values(ETypes).includes(value); // Функция вернет не просто bool значение, а bool значение с пренадлежностью к ETypes, не вызывая ошибок типов

const fn = (value: ETypes) => {
    // Тут должен быть код
};

const a = "big";
if (isValueEType(a)){ // Проверяем принадлежность a к EType через значение bool, которое должно быть связано с EType
    fn(a); 
}
```

# Исключающие объединения
Исключающие объединения (discriminated unions) используют для создания неявных предохранителей или предохранителей на определенные варианты:

```
type Member = {
 type: 'member'
 currentProject: string
}

type Admin = {
 type: 'admin'
 projects: string[]
}

type User = Member | Admin // Мы не знаем, что конкретно мы можем получить, однако знаем, что это одно из двух (или больше)

function getFirstProject(u: User) {
 if (u.type === 'member') {
   return u.currentProject
 }
 return u.projects[0]
}
```

# [Источник](https://habr.com/ru/companies/macloud/articles/557996/)
В качестве источника представлена статья на хабре
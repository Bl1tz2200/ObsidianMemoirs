#Программирование #ЯзыкиПрограммирования #Фреймворки

React - фреймворк для JavaScript который сильно упрощает веб-верстку. Основа React в том, что HTML элементы рендерятся с помощью JS, позволяя динамично ими управлять (например: добавили товар в корзину и на той же странице корзина обновилась, однако оптимизация зависит от количества компонентов на сайте). Сам код на React представляет собой JS вместе со встроенными функциями (Хуками)

Хочу упомянуть, что для установки React я использовал Vite, так же в качестве CSS я использовал sass и иногда вы можете тут встретить синтаксис TypeScript, советую со всем этим ознакомиться перед прочтением (кратенько)

У обычного React может возникать проблема с SEO оптимизацией (это когда при поиске в гугле будет выводится информация с вашего сайта), поэтому лучше использовать другой фреймворк Next.js, который тоже является React фреймворком, но с SEO оптимизацией. Также рекомендуется изучить TypeScript, он просто лучше, чем обычный JS, так как позволяет ловить ошибки до компиляции
# Комментарии
Комментарии в React ставятся как {/* КОММЕНТАРИЙ */}
или просто как // Комментарий

# Представление кода
Начнем с того, как выглядит код на React - обычно код преставляет различные функции, содержащиеся в одном файле. Они могут возвращать очень разные значения

На страницу сайта выводится результат указанных функций; обычно этот результат представляет собой сборник элементов DOM. Такие функции можно представить в виде одного большого элемента DOM, который отрендерится на странице, вот пример:

```
ReactDOM.createRoot(document.getElementById('root')).render( // Отрендерится 3 функции, каждая из которых возвращает определенную часть страницы сайта (кстати, такие функции и называют компонентами)
   <Home /> 
   <About-us />
   <Other />
)
```

Таким образом React позволяет гибко настраивать выводимую информацию и использовать JS как динамический HTML. React позволяет просто сочетать JS код с HTML элементами, ведь HTML элементы не указываются в отдельном файле, а генерируются самим JS кодом
# Экспортирование и импортирование
Для экспортирования различных функций или переменных в другие файлы перед ними необходимо указать export:

```
export default function Home() { // Экспортируем функцию Home (приписка default указывает, что эта функция импортируется по умолчанию)

  return (
    <>
      <h1>It is home page.</h1>
    </>
  )
}

export function Other() { // Экспортируем функцию Other

  return (
    <>
      <p>Other text</p>
    </>
  )
}
```

Тем временем в другом файле:
```
import {About-us} from './About-us.jsx'
import {Other} from './TwoComponents.jsx' // Для импортирования конкретных данных (например функции или переменных) из файла необходимо указать их название в {}
import Home from './TwoComponents.jsx' // В этом случае мы не указываем {} так как Home импортируется по умолчанию

ReactDOM.createRoot(document.getElementById('root')).render(
   <Home /> 
   <About-us />
   <Other />
)
```


Подробнее про экспортирование и импортирование см. [документацию](https://react.dev/learn/importing-and-exporting-components)

# Хуки
Что же такое хуки?
- Обычные функции, которые вызываются внутри компонента

В данный момент используют функциональные компоненты вместо классовых, из-за поддержки хуков функциональными компонентами
## Терминология
Поговорим про термины, которые необходимо знать:

`Callback` - прокидывание функции в какой-то компонент с дальнейшим её использованием в другом компоненте. Важно её кэшировать, иначе каждый раз у нас будет пересоздаваться функция, создавая проблемы с оптимизацией, однако закэшировав функцию мы можем потерять её изменений, например, ведь функция в кэше обновится только с обновлением сайта
## Встроенные хуки
А теперь подробнее про встроенные хуки и их использование:

`useState` - хук, который используют для создания переменной и функции её изменения. Пример:
```
const [details, setDetails] = useState({ // Создаем словать details с ключами text, description, functions
    text: null, 
    description: 'Nothing',
    functions: false,
  })

const onClick = () => { // Создаем функцию, по нажатию которой мы изменим значение description с 'Nothing' на 'title'
    setDetails(prev => (
      {
      ...prev, // Сокращенный вид того, что мы вставляем те же параметры prev, то есть копируем весь предыдущий details и вставляем его в новый, изменяя лишь description (нам же не надо случайно удалить другие ключи и значения) 
      description: 'title',
      }
  )}
```

`useEffect` - хук, который совершает действия при монтировании/размонтировании компонента, а так же при его изменении. Пример:
```
useEffect(() => { // Используем внутри него функцию, в нашем случае стрелочную
    console.log("Title changed!!!") // Выводим в консоль изменение названия
    return () => { // Эта часть кода выполнится при демонтаже элемента
      console.log("Title removed!!!")
    }
  }, [details.title]) // В скобках нужно указать переменную, при изменение которого выполниться useEffect (если ничего не указать, то useEffect выполнится только при монтировании страницы и её демонтаже (загрузке/закрытии страницы)) 
```

`useCallback` - хук, функция которого минимизировать этот самый Callback между рендерами страницы сайта, кэширует саму функцию. Пример:
```
 const handleFunctionUse = useCallback(() => { // создаем функцию handleFunctionUse, которая будет кэшироваться при использовании. Таким образом она не будет постоянно пересоздаваться так как всегда выполняет одно и тоже действие
    setDetails(prev => ({...prev, functions: !prev.functions})) // Банально меняем значение на противоположное
  }, [])
```

`useMemo` - хук, функция которого минимизировать результат функции, оптимизирует производительность за счет кэширования результата выполнения функции. Пример:
```
const result = useMemo(() => {return count * multiplier}, [count, multiplier]) // Кэшируем результат выполнения стрелочной функции, в которой мы производим математические вычисления. Таким образом можно избежать постоянного перерасчета без изменения элементов
// В квадратных скобках указываем переменные, после изменения которых функция выполнится снова и закэширует новый результат
```

`useRef` - хук, который позволяет создать изменяет объект ref, содержащий в себе информацию об элементе страницы сайта (например узнать значение поля для ввода). Пример:
```
const textRef = useRef<HTMLTextAreaElement | null>() //В <> указано какие параметры может принимать textRef на случай, если мы вдруг используем его в другом элементе (это синтаксис TypeScript)
const updateSelection = () => {
        if (!textRef.current) return // Если текущий элемент DOM не имеет ничего, то есть равен null, то мы возвращаем завершаем функцию без результата
	// Если предыдущая строчка не сработала, то код пойдет дальше
        console.log(textRef.current.value) // Выводим в консоль значение поля для ввода
    }

// Далее представлен вырванный из контекста элемент DOM (а именно поле для ввода), который дублируется в ref

<textarea ref={textRef}></textarea>
```

`useContext` - хук, который позволяет обернуть определенные части сайта, обеспечивая доступ к общим переменным (Такую обертку ещё называют провайдером)
Пример:

```
const AuthContext = createContext({ //Для начала создаем объект AuthContext, который и будет содержать в себе наши глобальные переменные
    isAuthed: false,
    setIsAuthed: null
})

const AuthProvider = ({children}) => { // Создаем провайдера AuthProvider, который принимает на вход наш элемент, а в замен предоставляет доступ к AuthContext
    const [isAuthed, setIsAuthed] = useState(false) // Задаем общие переменные, в нашем случае парамент isAuthed + функцию, для его изменения
    return ( <AuthContext.Provider> // Возвращаем обёрнутые в наш провайдер элементы (не забудте указать, что это именно провайдер через атрибут .Provider)
        {children}
    </AuthContext.Provider>)
}
```

Вырванный из контекста элементы DOM в качестве примера того, как их оборачивает провайдер:
```
<AuthProvider>
	<Home />
	<About-us />
	<Other />
</AuthProvider>
```

Для получения доступа к AuthContext теперь достаточно использовать `useContext` в вашем коде

```
const isUserAuthed = useContext(AuthContext).isAuthed; // Получаем значение из нашего словаря, доступ к которому обеспечивает провайдер (да, это опять код вырванный из контекста)
```

Конечно, в React огромное количество хуков, всех их можно увидеть на [официальной документации React](https://react.dev/reference/react/hooks)
Также вот [сайт, который рассказывает про основные хуки (помимо моих + другие примеры)]( https://vc.ru/u/1389654-machine-learning/670964-davaite-uglubimsya-v-react-hooks-react-168)

Думаю я обозначил всю базу React, в остальном это обычный JS, в котором все так же можно делать различные вычисления и взаимодействия с другими сервисами. У них довольно информативная документация и огромное количество фреймворков, которые основываются на React
# [Источник](https://www.youtube.com/watch?v=Fbsusu0xfpY)
В качестве источника представлено видео на ютубе. Хочу отметить, что видео предназначено для людей, уже работавших с JS, CSS, HTML, само же видео быстрое и информативное
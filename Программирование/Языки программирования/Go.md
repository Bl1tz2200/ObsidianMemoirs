#Программирование #ЯзыкиПрограммирования 

Golang (Go) - компилируемый многопоточный язык, созданный Google. Прост как питон, эффективен как плюсы

# Начало работы
В самом начале файла нужно указать, в каком пакете работает файл:

```
package main
```

Так же основной код выполняется в функции `main `
(да, для вывода чего-либо нужно импортировать библиотеку `fmt`):

```
package main

import "fmt"

func main() {
    fmt.Println("Hello world!")
}
```
# Запуск
Для запуска:

```
go run main.go
```

# Комментарии
Комментарии в Go такие же, как и в C++: 

```
// - однострочный комментарий
```

```
/* Это 
Многострочный 
комментарий */
```

# Сборка
Для сборки в exe:

```
go build main.go
```

Для сборки с оптимизацией памяти (сборка с уменьшенным размером exe файла):

```
go build -ldflags "-s -w" main.go
```

# Переменные
Для объявления переменной необходимо либо указать var, название переменной и тип:

```
var age int8 = 23 // int8 - выделение 8 байт памяти для int переменной
var number float64 = 275.672 // тоже самое с float, но с выделением 64 байт памяти
```

либо указать названием переменной с `:=` :

```
age := 23
number := 275.672
```

Все определится само

Так же можно использовать массовую инициализацию переменных:

```
var (
    age int8 // Просто инициализируем
    number = 275.672 // Сразу задаем
    )
```

Переменные в Go изолированные, то есть указанные в одних {} переменная не будет видна вне их (переменная, заданная в скобках if нельзя вызвать вне if)

## Форматирование строк
Форматирование строк в Go довольно простое, однако необычное: нельзя конкатенировать строки с помощью +, можно использовать запятую (,), но это добавит лишний пробел. Нормальное форматирование происходит с помощью `fmt.Printf()`:

```
fmt.Printf("This is my %d project", number) // Как видите, для подстановки значений в строку нужно использовать % вместе с типом данных в строке, и после строки, через запятую, указываем переменные, которые нам необходимо вставить в строку
```

Вот какие указатели нужно использовать в строке, для подстановки разных типов данных:
%d - int
%s - string
%f - float
Есть и другие, подробнее [тут](https://pkg.go.dev/fmt) 

Есть библиотека, которая позволяет форматировать строки: `strings`

# Ввод
Для получения данных от пользователя необходимо использовать ту же библиотеку `fmt`:

```
import "fmt"

func main() {
   var name string // Создаем пустую переменную
   fmt.Scan(&name) // Записываем информацию от пользователя в нашу переменную через указатель (&)
}
```

Однако `fmt.Scan` примет только одно слово до пробела, чтобы взять большую строку с пробелами, например: "яблочный пирог", нужно использовать библиотеку `bufio` + `os`:

```
import (
	"bufio"
	"os"
)

func main() {
   scanner := bufio.NewScanner(os.Stdin) // Инициализируем сканер
   scanner.Scan() // Запрашиваем значение
   name := scanner.Text() // Записываем полученные данные в виде текста в переменную
}
```

Для конкатенации строки и числа так же используют библиотеку `fmt` (строки и без неё конкатенируются):

```
fmt.Println("Your age" + fmt.Sprint(age))
```

Другие типы данных можно конвертировать между друг другом:

```
var h int8 = 2
var g float64 = float64(h)
```

# Условия
Условия в Go сильно не отличаются от других языков (|| - ИЛИ, && - И, != - не равно):

```
var num int8
fmt.Scan(&num)

if num > 0 {
    fmt.Println("1")
} else if num == 0 {
    fmt.Println("0")
} else {
    fmt.Println("Nothing")
}
```

# Цикл
В Go есть только 1 цикл - for, однако это не проблема ведь он может заменить другие:

```
for i := 0; i < 5; i++{ // Цикл for, как цикл с условием и итерацией (стандартный for)
    continue // Пропуск итерации цикла
}

for index, element := range nums{ // пример для перебора значений (например из списка), обязательно указывать 2 переменные (однако вместо index можно указать _, тогда Go просто не выделит память под неё и её можно будет не использовать)
    continue // Пропуск итерации цикла
}

for { // или for ;; {} - Цикл for, как бесконечный цикл while
    break // Разрываем цикл, завершая его
}

for i < 5{ // Цикл for, как цикл while
    break // Разрываем цикл, завершая его
}
```

# Switch
Есть в Go и switch:

```
name := "Kate"
switch name { // Указываем, какую перемнную будем проверять

case "John": // (Если name == John)
     fmt.Println("Named")

case "Kate": // (Если name == Kate)
     fmt.Println("WOMAN!!!!!")

case "Jordan": // (Если name == Jordan)
    fmt.Println("Nike")

default: // Срабатывает по умолчанию (если ничего другое не подошло)
    fmt.Println("No name found")
}
```

Обычно в `case`, после срабатывания условия, другие условия не сработают, то есть, условно, в конце каждого case стоит `brake`, однако этого можно избежать, поставив `fallthrough`, таким образом можно обработать другие условия `switch`

Можно использовать `switch` и для других условий, где нужно проверять разные переменные, например:

```
num := 1
switch {

case num > 1: // Если переменная num > 1
    fmt.Println("Num is greater than 1")
    fallthrough // Идем проверять дальше

case num > 2: // Если переменная num > 2
    fmt.Println("Num is greater than 1 and 2")
		
default:
    fmt.Println("No name found")
}
```
# Массивы
Массивы в Go очень напоминают C++ - задаем массив через указание количества элементов в массиве и типа данных, который будет в нём храниться:

либо
```
var arrayOfNames [3]string
	arrayOfNames[0] = "First name"
	arrayOfNames[1] = "Second name"
	arrayOfNames[2] = "Third name"
```

либо
```
arrayOfNames := [3]string{"First name", "Second name", "Third name"}
```

Большее количество элементов, чем указано при создании массива, засунуть в него нельзя

Пример перебора массива:

```
arrayOfNames := [3]string{"First name", "Second name", "Third name"}
for i := 0; i < len(arrayOfNames); i++ {
    fmt.Println(arrayOfNames[i])
}
```

С многомерными массивами примерно так же:

```
arrayOfNums := [3][4]int{{0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}} // Задаем многомерный массив
for i := 0; i < len(arrayOfNums); i++ { // перебираем его
    for j := 0; j < len(arrayOfNums[i]); j++ {
        fmt.Println(arrayOfNums[i][j])
    }
}
```
# Срезы
Есть в Go и срезы - динамические массивы

Чтобы задать его достаточно просто не указывать количество элементов в массиве:

```
slice := []int{3, 1, 2, 5, 6, 8, 9, -1}
```

Для добавления элементов в срез необходимо использовать `append`:

```
slice = append(slice, 0) // Добавить к срезу число 0 (добавляет только в конец)
```

Для сортировки среза можно использовать стандартную библиотеку `sort`:

```
slice := []int{3, 1, 2, 5, 6, 8, 9, -1, 0}
sort.Ints(slice) // Сортируем срез из int, есть так же и для string и тд
fmt.Println(slice) // Выводится: [-1 0 1 2 3 5 6 8 9]
```

Для перебора срезов используют метод `range`:

```
slice := []int{3, 1, 2, 5, 6, 8, 9, -1, 0}
sort.Ints(slice)
for i, el := range slice { // Используем range для вывода всех элементов массива, таким образом мы перебираем все индексы среза в i и элементы под этим индексом в el
    fmt.Printf("%d: %d\n", i, el) // Вывод с форматированием, где выводится i: el
}
```

Если нам не нужны индексы, можно их заменить на _:

```
slice := []int{3, 1, 2, 5, 6, 8, 9, -1, 0}
sort.Ints(slice)
for _, el := range slice { // Теперь индексы будут пропущены и мы просто переберем все элементы среза в el
    fmt.Println(el)
}
```

Каждый срез имеет 3 значения: длину (len), размер (ёмкость) (cap) и значение (ptr). Все они содержат ссылку на некий базовый массив, то есть если мы берем срез с нашего массива, благодаря этого изменяя срез мы изменяем и массив, с которого срез был взят

Чтобы не изменять наш массив, с которого мы берем срез, нужно использовать функцию `copy`:

```
newSlice := make([]int, len(slice1)) // Создаем новый срез с длиной slice1 и размером равному длинне newSlice, то есть тоже длинне slice1
cope(newSlice, slice1) // Копируем slice1 в newSlice для избежания случайных изменений
```

Если длина среза становится больше размера создается ещё один массив с размером в 2 раза больший предыдущего (да, это тоже может избежать изменение изначального массива, так как у нас создастся такой же массив, только с удвоенным размером), вследствие этого длина снова меньше или равна размеру

Обычно при создании среза сразу задают его длину и размер чтобы не пересоздавать его тысячи раз. Делают это через make:

```
slice1 := make([]int, 0, 10) // Срез с интовыми значениями, длина которого 0 (в нём нет ниодного значения), но при этом размер 10, то есть базовый массив был создан с параметрами [10]int{}
```

Подробнее про фокусы срезов [тут](https://www.youtube.com/watch?v=10LW7NROfOQ&t=1338s) 
# Map
Есть в Go карты, называются map, очень напоминают словари, но с авто сортировкой

Они достаточно простые в использовании, но вот как они устроены изнутри... Вот [видео с более подробным объяснением](https://www.youtube.com/watch?v=P_SXTUiA-9Y) 

Насколько я понял, для ускорения методов нахождения ключа и значения используют методы `bucket` (сортировать ключи и значения по спец признакам), так же есть hash функция, которая кодирует ключ и используется при сортировке. Таким образом, через hash ключа мы можем быстрее найти его

Создаются просто:
либо
```
var money map[string]int = map[string]int{ // сначала в [] указываем тип данных у ключа, затем, после них, указываем тип данных значения
    "dollars":           1000,
    "euros":             2000,
    "argentine_dollars": 3,
}
```

либо
```
money := map[string]int{
    "dollars":           1000,
    "euros":             2000,
    "argentine_dollars": 3,
}
```

Для изменения элемента под ключом нужно:

```
money["dollars"] = 2000 // Изменяем значение под ключом dollars на 2000
```

Можно даже выписывать ключ-значение в переменные:

```
i, el := money["dollars"]
fmt.Println(i, el) // Вывод: dollars 1000
```

Если мы попробуем получить несуществующий ключ, то получим 0 в ключе и false в значении:

```
i, el := money["rubles"]
fmt.Println(i, el) // Вывод: 0 false
```

Перебор карты:

```
for key, value := range money { 
    fmt.Printf("%s: %d\n", key, value) 
}
```
# Функции
Функции в Go тоже очень напоминают С++:

```
func hello_world(name string) { // Создаем новую функцию вне main, в скобках указываем переменную и её тип данных
    fmt.Println("Hello", name)
}

func main() {
    var a string
    fmt.Scan(&a)
    hello_world(a) // используем функцию, отправляя ей перемнную с нужным типом данных
}
```

Для возврата результата от функции необходимо указать тип данных, который будет возвращать наша функция:

```
func sum(a int, b int) int { // после () указываем int - то, что будет возвращать функция
	return a + b
}

func main() {
    var a int
    fmt.Scan(&a)
    var b int
    fmt.Scan(&b)
    fmt.Println(sum(a, b)) // Отправляем в нашу фукнцию две переменные, а затем выводим вернувшийся результат
}
```
Так же можно возвращать сразу несколько переменных:

```
func sum(a int, b int) (int, int, int) {
    return a + b, a, b
}

func main() {
    var a int
    fmt.Scan(&a)
    var b int
    fmt.Scan(&b)
    get_sum, var_a, var_b := sum(a, b)
    fmt.Println(get_sum, var_a, var_b)
}
```

ИЛИ можно сразу создать переменные в функции, а затем их менять

```
func sum(a int, b int) (sum int, var_a int, var_b int) {
    sum = a + b
    var_a = a
    var_b = b
    return
}

func main() {
    var a int
    fmt.Scan(&a)
    var b int
    fmt.Scan(&b)
    get_sum, var_a, var_b := sum(a, b)
    fmt.Println(get_sum, var_a, var_b)
}
```
## Создание функций
Для создания функций внутри главной необходимо задать её в переменную:

```
func main() {
    sum := func(a int, b int) int {
        return a + b
    }
    fmt.Println(sum(5, 7))
}
```

Используют это, чтобы, например, ссылаться на функцию в другой функции:

```
func print_result(somefunction func(int, int) int) { // Создаем функцию print_result, принимающую на вход другую функцию, которая принимает 2 int и возвращает тоже int
     fmt.Println(somefunction(5, 7))
}

func main() {
    sum := func(a int, b int) int {
        return a + b
    }
    print_result(sum) // Указываем нашу функцию, которую мы хотим вывести. Заметьте: без (), мы ссылаемся на sum, а не используем эту функцию (как если бы мы написали sum())
}
```

Точно так же можно возвращать функции:

```
func text(txt string) func() { // Создаем функцию, которая вернет функцию, приняв string
    return func() { // Возвращаем функцию 
        fmt.Println(txt)
    }
}

func main() {
    print_text := text("My text") // Получаем функцию
    print_text() // Используем функцию
    // Можно заменить на print_text := text("My text")(), так функция сразу же используется
}
```
# Указатели и ссылки
Указатели и ссылки, то есть & и * 

Что же такое указатель? Адрес ячейки памяти, которая была выделена под нашу переменную
Что же такое ссылка? Это значение переменной, находящийся в определенной ячейке памяти

Примеры:
```
a := 5
pointer := &a
// можно создать так же с помощью var pointer *int = &a
fmt.Println(pointer) // Выводит адрес в памяти, принадлежащий нашей переменной
fmt.Println(*pointer) // Выводит 5, то есть значение переменной, находящийся по этому адресу памяти
```

Используют это для, например, изменения значения через функцию.
Обычно функция не может просто поменять значение переданной переменной внутри себя, она просто создаст новую:

```
func change_num(number int) {
	number = 10
}

func main() {
	a := 5
	fmt.Println(a) // Выводит: 5
	change_num(a)
	fmt.Println(a) // Все так же выводит: 5
}
```
Для переопределения переменной необходимо использовать ссылки и указатели:

```
func change_num(number *int) {
	*number = 10
}

func main() {
	a := 5
	fmt.Println(a) // Выводит: 5
	change_num(&a)
	fmt.Println(a) // Выводит: 10
}
```
# Структуры
Структуры или же личные типы данных, создаются структуры вне функции `main`:

```
type User struct { // User - название структуры
    name     string // Указываем название атрибута в структуре и его тип данных
    age      int64  // Да да, это называют атрибутами (вроде)
    password string
    score    []int // Примерно так выглядит атрибут структуры в виде среза int
}

func main() {
    var user User = User{name: "UrName", age: 28, password: "password"} // Инициализируем структуру с именем UrName возрастом 28 и паролем password
/*  Можно так же создать структуру с помощью
    user := User{name: "UrName", age: 28, password: "password"}
    или
    user := User{"UrName", 28, "password"} */
    user.age = 44 // Можно менять значения в структуре, обращаясь к атрибутам отдельно
    fmt.Println(user)
}
```

Для изменения атрибутов через функцию необходимо указывать ссылку на ваш тип данных:

```
type User struct {
    name     string 
    age      int64  
    password string
}

func change_age(usr *User) {
    usr.age = 44
}

func main() {
    user := User{"UrName", 28, "password"}
    change_age(&user)
    fmt.Println(user) // Выводит: {UrName 44 password}
}
```

Однако, истинные разработчики используют специальные функции для получения атрибутов структуры и их изменения
Пример таких функций:

```
func (usr *User) set_age(age int64) { // В первых скобках задаем нашу структуру с ссылкой, так как мы изменяем её атрибут
	usr.age = age // Затем просто меняем атрибут через функцию, которая принимает значение переменной 
}

func (usr User) get_age() int64 { // Эта же функция используется для получения возраста и его возврата, поэтому мы не указываем переменные
	return usr.age // Возвращаем наш возраст
}
```
# Интерфейсы
Есть в Go интерфейсы, то есть функции, которые нужны для закрепление функций за структурами, обычно такие функции называют методами

Для того, чтобы прописать методы мы:

```
type Numbers struct { // Создаем нашу структуру
	a int
	b int
}

type NumbersInterface interface { // Создаем интерфейс
	Sum() int // Метод Sum, возвращающий int
	Multiply() int // Метод Multiply, возвращающий int
	Division() float64 // Метод Division, возвращающий float64
	Substract() int // Метод Substract, возвращающий int
}

func (nums Numbers) Sum() int { // Описываем методы для структуры
	return nums.a + nums.b
}

func (nums Numbers) Multiply() int { // Описываем методы для структуры
	return nums.a * nums.b
}

func (nums Numbers) Division() float64 { // Описываем методы для структуры
	return float64(nums.a / nums.b)
}

func (nums Numbers) Substract() int { // Описываем методы для структуры
	return nums.a - nums.b
}

func main() {
	var intrfc NumbersInterface // Инициализируем интерфейс
	numbers := Numbers{1, 10} // Инициализируем структуру
	intrfc = numbers /// Указываем инициализированную структуру интерфейсы
	fmt.Println(intrfc.Sum()) // Выводим сумму через метод Sum
	fmt.Println(intrfc.Substract()) // Выводим вычитание через метод Substract
	fmt.Println(intrfc.Multiply()) // Выводим умножение через метод Multiply
	fmt.Println(intrfc.Division()) // Выводим деление через метод Division
}
```
# Асинхронность
Ну вот мы и добрались до асинхронности Go 

Go имеет асинхронные функции и, как их называют, горутины. Зачем же они нужны? Скажем так, когда вы готовите суп вам нужно вскипятить воду, нарезать овощи, закинуть овощи в кипящую воду. Обычные языки программирования сначала вскипятят воду, потом нарежут овощи, потом кинут их в суп, асинхронные же, как и люди, сначала поставят суп кипятиться и за это время нарежут овощи, которые потом сразу добавят в суп, используют оно для этого разные потоки (условно как мы выполняем функции в разных окнах на компьютере). Таким образом мы, в разных потоках (да, Go многопоточный язык), может выполнять разные функции параллельно

Для использования горутины нужно написать `go` перед функцией

Приведу пример:

```
func say(greet string) { // Создадим простую функцию
    fmt.Println(greet)
}

func main() {
    go say("Hello world!") // Запустим её парралельно нашему основному потоку 
    time.Sleep(2 * time.Second) // Задержим наш основной поток с помощью библиотеки time. Дело в том, что наш основной поток сработает быстрее, чем горутина, поэтому нам не выведется её результат
}
```

Так как асинхронность достигается за счет разных потоков, появляется некоторая особенность при обмене данными: необходимо создать канал между потоками, чтобы что-то передать и получить

Rаналы довольно просто устроены изнутри ([подробнее про устройство каналов](https://www.youtube.com/watch?v=ZTJcaP4G4JM)), они отправляют копию данных, а не их самих

Вот пример работы канала в коде:

```
func say(greet string, ch chan int) { // Указываем в переменных функции канал для передачи данных
    fmt.Println(greet)

    ch <- 10 // Отправляем число 10
}

func main() {
    ch := make(chan int) // Создаем канал для передачи int через функцию make (после chan int, через запятую, можно указать размер буфера числом (если не понял, см. видео про устройство каналов))

    go say("Hello world!", ch) // Указываем созданный канал
    fmt.Println(<-ch) // Получаем данные из канала с помощью <- (функция main будет ждать, пока из другого потока не придет значение, поэтому можно не использовать time.Sleep)
}
```

Однако с этим приходит проблема: мы можем случайно не закрыть канал, когда, например, главный поток будет ждать данные из другого потока, хотя они не придут. Для этого нужно закрыть канал вручную, то есть прописать `close()`

Приведу пример:

```
func say(ch chan int) {
    for i := 0; i <= 5; i++ { 
        fmt.Println(i)
        ch <- i // Отправим от 0 до 5 по каналу
    }

    close(ch) // Закрываем канал после завершения передачи данных
}

func main() {
    ch := make(chan int)

    go say(ch)
    for a := range ch { // range не знает сколько всего значений, поэтому будет ждать следующего числа, даже если оно не придет, однако мы закрыли канал, поэтому ошибки не будет
        fmt.Println(a)
    }
}
```

Можно задать количество записей, которые можно передать через канал:

```
ch := make(chan string, 4) // После передачи 5 записи вылезет ошибка так как стоит ограничение в 4 записи
```

Используя синтаксис `v, ok := <-ch` можем получить статус канала в виде `bool`, записанного в ok (true - открыт, false - закрыт)

Используя `select` вместо `switch` мы можем подождать значения из разных каналов, однако тут первым проверится тот `case`, чьё значение на проверку пришло первым, а default сработает тогда, когда на момент select ни один из канал ни готов для чтения

Используя библиотеку `sync` можно задавать `WaitGroup`, которые позволят задерживать асинхронные процессы до завершения другого процесса, чтобы, например, у игрока успели списаться очки до того, как он снова попытается их потратить (это ещё называют Мьютекс (Мьютекс (от англ. mutual exclusion — взаимное исключение) — это примитив синхронизации, который обеспечивает исключительный доступ к общему ресурсу для одного потока или процесса))

# Работа с файлами
В Golang так же можно работать с файлами, осуществляется через библиотеку os:

```
import (
	"fmt"
	"os"
)

func main() {
	file, err := os.Create("text.txt") // Создаем файл, указывая в переменные сам файл и возможную ошибку

	if err != nil { // Отрабатываем ошибку, если она не нулевая, то выводим её и завершаем работу с кодом 1
		fmt.Println(err)
		os.Exit(1)
	}

	defer file.Close() // Используем defer для внесения file.Close() в обязательную команду, которая выполнится при завершении функции, то есть закроет файл после конца работы программы

	data := "Text to file" // Наша строка, которую мы будем записывать в файл

	file.WriteString(data) // Записать строку в файл

	file_data, _ := os.ReadFile(file.Name()) // Получим данные с файла (на этот раз не отрабатываем ошибку, поэтому не получаем её, заменив переменную на _
	fmt.Println(string(file_data)) // Выводим полученные данные с файла, однако сначала конвертируем их в string (по умолчанию данные с файла в битах)
	os.Remove("text.txt") // Удаляем файл
}
```

# Библиотека math
Для математических операций используют библиотеку math (помимо стандартных *, /, +, -, %)

math достаточно логичная библиотека:
```
math.Sqrt(variable) // вычислить корень
math.Ceil(variable) // Округление к большему значению, то есть 25.2541 => 26
math.Floor(variable) // Округление к меньшему значению, то есть 25.9999 => 25
math.Round(variable) // Округление к ближайшему числу, то есть 25.2541 => 25, 25.9999 => 26, но 25.49 => 25, 25.5 => 26
```

# Пример кода
В качестве полноценного примера кода могу предоставить небольшую текстовую игру на скорость печати на Go
![[Программирование/Языки программирования/Примеры/Go/cooking_game.go]]
# [Источник](https://www.youtube.com/playlist?list=PLgG7lPwNdp57aUoqLpR0Rk7Q5v4dFHsjg)
В качестве источника представлен плейлист на ютубе